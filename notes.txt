current issue is having squares initialize as none causes every square.method to throw an error, fair enough
so what do I do 

have square still initialize as their objects, and have square.method available -> but method for checking if square is populated needs to be fixed

into something like -> return True if self.piece. else False

solved that none tpye dumb bug

piece movement, consider all possible moves like pawn captures diagonally
prune those moves if destination square is not ocupied by opponents piece
or if the pawn moved already then it cannot go two squares forward


###
seems like i have a "captured" arg in initializing a piece object.
and it sets self.exists to false.
and it's used in clear() square method

that looks very odd, possibly gonna cause big bug

so if you move a piece, and clear previous start square after legit move, you should clear that squares piece object
maybe i just called it caputre by mistake, need to figure how its actually used in game flow.


possible bug, when checking the path to a given square from x via 1d array like file or diagonal
how does the logic for checking path to destination both ways work, if we are splitting by square ok, if by piece then having two pawns in same file could bug it out??
edit: i think we chilling, it's only squares checked, and getting indicies of the path array for math based path calculation and the path is checked simply by if the square is ocupied bleh